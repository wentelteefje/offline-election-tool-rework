// src/onchain_exposures.rs

use std::collections::BTreeMap;

use anyhow::{Context, Result};
use subxt::config::substrate::AccountId32;
use subxt::utils::H256;
use subxt::{OnlineClient, config::PolkadotConfig};

use crate::asset_hub;
use crate::types::{AccountId, Balance, Hash};

// Generated by subxt for pallet-staking-async:
use crate::asset_hub::api::runtime_types::{
    pallet_staking_async::ActiveEraInfo, sp_staking::PagedExposureMetadata,
};

/// Convert runtime `AccountId32` into local `[u8; 32]` alias.
fn account32_to_local(acc: AccountId32) -> AccountId {
    *acc.as_ref()
}

/// Convert local `[u8; 32]` alias into runtime `AccountId32`.
fn local_to_account32(acc: AccountId) -> AccountId32 {
    AccountId32::from(acc)
}

/// On-chain backer (nominator / delegator) entry.
#[derive(Clone, Debug)]
pub struct OnchainBacker {
    pub who: AccountId,
    pub stake: Balance,
}

/// One page of exposure for a validator in a given era.
///
/// Async staking `ExposurePage` does not contain `own` / `total`,
/// only `page_total` and `others`. Validator self-stake and total stake across
/// all pages are stored in `ErasStakersOverview`.
#[derive(Clone, Debug)]
pub struct OnchainExposurePage {
    pub validator: AccountId,
    pub page_index: u32,
    pub page_total: Balance,
    pub others: Vec<OnchainBacker>,
}

/// Map: validator -> all exposure pages.
pub type OnchainExposurePagesMap = BTreeMap<AccountId, Vec<OnchainExposurePage>>;

/// Overview for a validator at a given era, from `ErasStakersOverview`.
///
/// Stores:
/// - total backing (own + all nominators),
/// - validator self stake,
/// - counts for nominators and pages.
#[derive(Clone, Debug)]
pub struct OnchainExposureOverview {
    pub total: Balance,
    pub own: Balance,
    pub nominator_count: u32,
    pub page_count: u32,
}

/// Map: validator -> overview.
pub type OnchainExposureOverviewMap = BTreeMap<AccountId, OnchainExposureOverview>;

/// Fetch the active era index at a given block hash on AssetHub.
pub async fn fetch_active_era_at(client: &OnlineClient<PolkadotConfig>, at: Hash) -> Result<u32> {
    let at_hash = H256::from(at);

    let storage = client.storage().at(at_hash);
    let root_storage = asset_hub::api::storage();
    let staking = root_storage.staking();

    // ActiveEra: ActiveEraInfo { index: EraIndex, start: Option<u64> }.
    let active_addr = staking.active_era();
    let active: ActiveEraInfo = storage
        .fetch(&active_addr)
        .await?
        .context("ActiveEra storage returned None at this block")?;

    Ok(active.index)
}

/// Fetch the planned era (`CurrentEra`) index at a given block hash on AssetHub.
pub async fn fetch_current_era_at(client: &OnlineClient<PolkadotConfig>, at: Hash) -> Result<u32> {
    let at_hash = H256::from(at);

    let storage = client.storage().at(at_hash);
    let root_storage = asset_hub::api::storage();
    let staking = root_storage.staking();

    // CurrentEra: plain `u32`.
    let addr = staking.current_era();
    let era: u32 = storage
        .fetch(&addr)
        .await?
        .context("CurrentEra storage returned None at this block")?;

    Ok(era)
}

/// Fetch on-chain paged exposures from `pallet-staking-async` (`Staking`)
/// for a given era and set of validators at a specific block.
///
/// Parameters:
/// - `at`: `[u8; 32]` block hash.
/// - `era`: era index to inspect.
/// - `validators`: winners / candidates to fetch exposures for.
/// - `max_pages_per_validator`: safety bound (for example: 16, 32 or a runtime upper bound).
///
/// Iteration stops for a validator at the first `None` page.
///
/// Matches `ErasStakersPaged(era, stash, page)` where:
///   `ErasStakersPaged = BoundedExposurePage`
///   and `BoundedExposurePage(pub ExposurePage<AccountId32, u128>)`.
pub async fn fetch_onchain_exposures_for_era(
    client: &OnlineClient<PolkadotConfig>,
    at: Hash,
    era: u32,
    validators: &[AccountId],
    max_pages_per_validator: u32,
) -> Result<OnchainExposurePagesMap> {
    let at_hash = H256::from(at);

    let storage = client.storage().at(at_hash);
    let root_storage = asset_hub::api::storage();
    let staking = root_storage.staking();

    let mut result: OnchainExposurePagesMap = BTreeMap::new();

    for validator in validators {
        let stash_runtime = local_to_account32(*validator);
        let mut pages: Vec<OnchainExposurePage> = Vec::new();

        // Iterate pages 0..max_pages_per_validator and stop at first `None`.
        for page_index in 0..max_pages_per_validator {
            let addr = staking.eras_stakers_paged(era, stash_runtime.clone(), page_index);

            let page_opt = storage.fetch(&addr).await?;

            let Some(bounded_page) = page_opt else {
                break;
            };

            // BoundedExposurePage(pub ExposurePage<AccountId32, u128>).
            let inner = bounded_page.0;

            let page_total: Balance = inner.page_total;

            let others: Vec<OnchainBacker> = inner
                .others
                .into_iter()
                .map(|ind| OnchainBacker {
                    who: account32_to_local(ind.who),
                    stake: ind.value,
                })
                .collect();

            pages.push(OnchainExposurePage {
                validator: *validator,
                page_index,
                page_total,
                others,
            });
        }

        if !pages.is_empty() {
            result.insert(*validator, pages);
        }
    }

    Ok(result)
}

/// Fetch `ErasStakersOverview[era][validator]` on AssetHub.
///
/// Returns `Ok(None)` if there is no overview for this validator in that era
/// (for example, not in the active set).
pub async fn fetch_overview_for_validator(
    client: &OnlineClient<PolkadotConfig>,
    at: Hash,
    era: u32,
    validator: AccountId,
) -> Result<Option<OnchainExposureOverview>> {
    let at_hash = H256::from(at);
    let storage = client.storage().at(at_hash);

    let root = asset_hub::api::storage();
    let staking = root.staking();

    let stash_32 = local_to_account32(validator);
    let addr = staking.eras_stakers_overview(era, stash_32);

    // `PagedExposureMetadata<Balance>`.
    let meta_opt: Option<PagedExposureMetadata<u128>> = storage
        .fetch(&addr)
        .await
        .context("failed to fetch ErasStakersOverview")?;

    let overview = meta_opt.map(|meta| OnchainExposureOverview {
        total: meta.total,
        own: meta.own,
        nominator_count: meta.nominator_count,
        page_count: meta.page_count,
    });

    Ok(overview)
}

/// Fetch overviews for a set of validators.
///
/// Validators that have no on-chain exposure in that era are absent
/// from the returned map.
pub async fn fetch_overviews_for_validators(
    client: &OnlineClient<PolkadotConfig>,
    at: Hash,
    era: u32,
    validators: &[AccountId],
) -> Result<OnchainExposureOverviewMap> {
    let mut map = BTreeMap::new();

    for &val in validators {
        if let Some(ov) = fetch_overview_for_validator(client, at, era, val).await? {
            map.insert(val, ov);
        }
    }

    Ok(map)
}

/// Flatten paged exposures into a per-validator, per-nominator stake map.
///
/// Produces:
///
/// `BTreeMap<validator, BTreeMap<nominator, stake>>`
pub type OnchainBackerMap = BTreeMap<AccountId, Balance>;
pub type OnchainFlattenedExposures = BTreeMap<AccountId, OnchainBackerMap>;

pub fn flatten_onchain_backers(pages: &OnchainExposurePagesMap) -> OnchainFlattenedExposures {
    let mut result: OnchainFlattenedExposures = BTreeMap::new();

    for (validator, v_pages) in pages {
        let entry = result.entry(*validator).or_insert_with(BTreeMap::new);

        for page in v_pages {
            for backer in &page.others {
                let stake_entry = entry.entry(backer.who).or_insert(0u128);
                *stake_entry = stake_entry.saturating_add(backer.stake);
            }
        }
    }

    result
}
